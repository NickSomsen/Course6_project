---
title: "Data Analysation"
author: "Gabe van den Hoeven, Tom Ummenthun and Nick Somsen"
date: "datum-komt-hier"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
<br> <!-- voor een extra witregel -->

## Loading the dataset

Als eerst moet het bestand in R worden ingelezen. Dit is gedaan met behulp van de library here, die de current working directory met `here()` ophaald, en vervolgens wordt dit samengeplakt met een opgegeven bestandsnaam. Van de data in het bestand is vervolgens een data frame gemaakt met `read.table()`. De identifiers voor de rijen (`row.names`) zijn de gennamen, die in kolom 1 van het bestand staan.
``` {r create data frame, message = FALSE, warning = FALSE}
library(here)
file_name = paste(here(), "RNA-Seq-counts.txt", sep = "/")
data_frame = read.table(file = file_name, sep = "\t", header = TRUE, row.names = 1)
```

De data frame ziet er als volgt uit (alleen de eerste 10 regels):
```{r show data frame, echo=FALSE}
options(width = 100) # ik pas de breedte aan zodat alle kolommen op dezelfe line kunnen
head(data_frame, 10)
```

Om makkelijk met de count data te kunnen werken, wordt er van de data frame een DGEList object gemaakt. `DGEList()` is een functie van `edgeR`, die dus eerst nog geïmporteerd moet worden:
```{r load edgeR, message=FALSE}
library(edgeR)
```

Voor een DGEList moet de counts data (vanuit de dataset) en de groups worden opgegeven. De groups is een factor die de mogelijke condities van de samples aangeven (dus welke _L. plantarum_ stam het is en of het een glucose of ribose voedingsbodem is). Het aanmaken van die groups gaat als volgt (je hoeft niet aan te geven welke de eerste is en welke de duplo met 1 of 2; dat gebeurt later automatisch):
```{r factor for DGEList}
exp = c("WCFS1.glc","WCFS1.glc","WCFS1.rib","WCFS1.rib", "NC8.glc", "NC8.glc", "NC8.rib", "NC8.rib")
group = factor(exp)
```

Nu kan het DGEList object aangemaakt worden. Voor de `counts` parameter moeten de counts vanuit de dataframe geselecteerd worden. De `group` parameter is de eerder aangemaakte group factor.
```{r create DGEList}
y <- DGEList(counts=data_frame[,1:8], group=group)
testDGE = DGEList(counts=data_frame[,1:8], group=group)
```

Het printen van de DGEList leverd het volgende resultaat:
```{r show DGEList, echo=FALSE}
y
```

## Normalize the data
Zodat de data met elkaar vergeleken kan worden, moet de data genormaliseerd worden. Hierdoor wordt bijvoorbeeld het effect van biologischefactoren die buiten je macht om de data beïnvloeden, geminimaliseerd.

Er zijn verschillende manieren om data te normaliseren. Eén van deze manieren is de Trimmed Mean Method (TMM). De TMM methode is een normalisatie methode waarbij het gemiddelde pas wordt berekend, nadat een bepaalde hoeveelheid van de laagste en hoogste waarden van de dataset zijn verwijderd. De hoeveelheid waarden die van beide kanten worden weggegooid kunnen absolute aantallen zijn of percentages, vaak dezelfde hoeveelheid voor beide kanten. 

Nadat deze outliers van de dataset zijn verwijderd, wordt de trimmed mean bepaald aan de hand van een formule. De trimmed mean wordt gebruikt omdat het uitschieters niet mee neemt in de berekeningen, die anders de data op een negatieve manier zouden beïnvloeden. Bovendien wordt door het uitsluiten van de uitschieters een beter beeld van de werkelijkheid verkregen. 

De trimmed mean, en andere metingen en waarden, geven een basis voor de vergelijking van de data.

In R kan de trimmed mean normalisatie methode worden uitgevoer met `calcNormFactors()`, een functie van de `edgeR` library:
```{r normalize data}
y <- calcNormFactors(y, method="TMM")
testDGE = calcNormFactors(testDGE, method="TMM")
y
```
Alleen tijdens de berekening van de normalisatiefactoren worden de kleinste en hoogste waarde tijdelijk niet meegenomen, maar deze waarden blijven wel gewoon in het data object zitten. Wanneer er vervolgens verdere berekeningne worden gedaan met de dataset, zitten de kleinste en hoogste waarden hier dus gewoon weer bij. De vermeningvuldiging van counts met normalisatiefactor vindt automatisch plaats wanneer er met het data object gerekend wordt. 

Vervolgens wordt er een design matrix gemaakt, die data aan elkaar linkt. Een design matrix is "a matrix of values of explanatory variables of a set of objects. Each row represents an individual object, with the successive columns corresponding to the variables and their specific values for that object" [via https://en.wikipedia.org/wiki/Design_matrix]. In R kan er een design matrix worden gemaakt met de `model.matrix()` functie. Het object waarover de design matrix moet worden gemaakt wordt opgegeven als de eerste parameter. De data vanuit de data frame die gelinkt moet worden aan het object wordt met de `data` parameter opgegeven. De kolommen van de design matrix krijgen een naam met de `colnames()` functie.
```{r design matrix}
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- levels(y$samples$group)

testDesign = model.matrix(~0+group, data=y$samples)
colnames(testDesign) = levels(testDGE$samples$group)
```
De design matrix ziet er als volgt uit:
```{r view design matrix, echo=FALSE}
design
```

Na de normalisatie kan er nog gefilterd worden op low read counts. Soms hebben genen zulke lage read counts, dat ze niet interessant zijn voor dit onderzoek, en deze genen worden dan eruit gefilterd. `edgeR` heeft hier een functie voor: `filterByExpr`. Als parameters worden het DGEList object, de design matrix en een count threshold meegegeven. De `min.total.count` parameter geeft de threshold aan van het aantal read counts die één hele rij in de data frame moet hebben (dus over 8 kolommen). 1000 / 8 = 125 read counts moet elke kolom gemiddeld hebben, om significant te zijn. Met de niet gebruikte `min.count` parameter kan de threshold per kolom worden bepaald. Hiervoor is niet gekozen, omdat wanneer de ene stam bijvoorbeeld wel significant is, en de andere stam niet, dan blijven alleen de genen van één stam in de data zitten, waardoor je niet meer tussen de stammen kunt vergelijken.
```{r filter for low read counts}
keep = filterByExpr(y, design, min.total.count = 1000)
y = y[keep,]

testDGE = testDGE[keep,]
summary(keep) # 302 genen van de 2219 worden eruit gefilterd (~13%)
```

## Calculate the dispersion
Om de spreiding tussen de data te bepalen, moet de dispersie worden berekent. Hiervoor zijn er verschillende functies beschikbaar in de `edgeR` library. Om zoveel mogelijk informatie te verkrijgen, worden er meerdere grafieken in dezelfde figuur geplot. Dit zijn de volgende grafieken:

1. De tagwise dispersie grafiek, waarbij elk datapunt één gen voor stelt.
2. De common dispersie grafiek, die een gemiddelde weer geeft van alle data, en daardoor constant is
3. De trend dispersie grafiek, die een trendlijn trekt door de tagwise datapunten.

Deze grafieken zijn met de volgende functies aangemaakt, en worden opgeslagen in het DGEList object:
```{r calculate dispersion}
testDGE = estimateGLMCommonDisp(testDGE,testDesign)  
testDGE = estimateGLMTrendedDisp(testDGE,testDesign, method="power") #op advies van Philip hadden we deze uitgezet.
testDGE = estimateGLMTagwiseDisp(testDGE,testDesign)
y = estimateDisp(y, design)
```

De dispersie kan dan als volgt worden geplot:
```{r dispersion plot}

temporaryplot = plotBCV(testDGE)
title("3 seperate commands")
correctplot = plotBCV(y)
title("1 single command")

```

In de figuur is te zien dat de variatie afneemt, naarmate de counts toenemen.

Ook kan nu de correlatie worden bepaald tussen de duplo's onderling, en over de verschillende condities en de _L. plantarum_ stammen. Dit kan in een grafiek worden geplot:
```{r correlation plot}
plotMDS(y)
```

In deze grafiek kan op de eerste dimensie (x-as) afgelezen worden hoever de glucose en ribose groepen uit elkaar liggen. Op de tweede dimensie (y-as) kan afgelezen worden hoever de duplo metingen uit elkaar liggen. Dit verschil tussen de duplo metingen moet klein zijn; was dit verschil groot geweest, dan betekent dat dat er veel verschillen zaten tussen de duplo metingen, wat ongewild is, en bovendien suggereerd dat de condities tijdens de twee metingen niet gelijk waren. Het verschil tussen de glucose en ribose condities mag logischerwijs wel groter zijn, net als de verschillen tussen de WCFS1 en NC8 stammen.

In de figuur is te zien dat bij beide _L. plantarum_ stammen de glucose en ribose metingen wat verder uit elkaar liggen (een afstand van ongeveer 2). In de tweede dimensie is te zien dat de twee stammen onderling ook ongeveer 2 uit elkaar liggen. Verder is er te zien dat er weinig verschil is tussen de duplo metingen, doordat de datapunten elkaar overlappen.

## Calculate fold changes
Om verschil tussen genexpressie te bepalen, worden de fold changes van de genexpressie levels berekend. Ook worden hiervoor p-values berekent, om betrouwbaarheid te controleren. Hiervoor moet er eerst een model worden gefit voor de read counts van elk gen. Dit wordt gedaan met `glmFit`, een functie van `edgeR`. Daarna kan het contrast tussen de verschillende groepen worden bepaald met de `makeContrasts` functie van de library `limma` (die tegelijk met `edgeR` wrodt ingeladen). Wanneer dat is gedaan, wordt er opniew een model gefit met de `glmLRT` functie, ook van `edgeR`. Omdat bij de `makeContrasts` functie maar twee groepen tegelijk met elkaar vergeleken kunnen worden, moeten deze stappen twee keer worden uitgevoerd: één keer voor het verschil in genexpressie van de verschillende voedingsbodems voor de WCFS1 stam en één keer hetzelfde voor de NC8 stam. 

Als eerst voor de WCFS1 stam:
```{r calculate fold changes WCFS1}
fit = glmFit(y, design)
mc = makeContrasts(exp.r=WCFS1.rib-WCFS1.glc, levels=design) 
fit = glmLRT(fit, contrast=mc)
wcfs1 = topTags(fit, n = nrow(fit))
```

De genen met het grootste verschil in fold changes (en dus expressie) tussen een glucose en ribose voedingsbodem van de WCFS1 stam kunnen dan worden weergegeven met `topTags`, dat defalut filtert op p-value:
```{r display top tags WCFS1}
print(topTags(fit))
```

In een plot:
```{r plot FC WCFS1}
plot(fit$table$logFC, main = "Fold Changes per gene visualized for the WCFS1 strain", xlab = "Gene #", ylab = "Fold Change value")
# text(0:nrow(fit$table), fit$table$logFC, labels = row.names(fit$table)) # dit zet de namen van de genen op de dataputnen, maar het is niet heel overzichtelijk
# fit$table["lp_0262",] # dit was even een controle 
```


En vervolgens voor de NC8 stam:
```{r calculate fold changes NC8}
fit = glmFit(y, design)
mc = makeContrasts(exp.r=NC8.rib-NC8.glc, levels=design) 
fit = glmLRT(fit, contrast=mc)
nc8 = topTags(fit, n = nrow(fit))
```

De genen met het grootste verschil in fold changes (en dus expressie) tussen een glucose en ribose voedingsbodem van de NC8 stam kunnen dan ook worden weergegeven:
```{r display top tags NC8}
print(topTags(fit))
```

Ook weer in een plot:
```{r plot FC NC8}
plot(fit$table$logFC, main = "Fold Changes per gene visualized for the NC8 strain", xlab = "Gene #", ylab = "Fold Change value")
# text(0:nrow(fit$table), fit$table$logFC, labels = row.names(fit$table)) # dit zet de namen van de genen op de dataputnen, maar het is niet heel overzichtelijk
```

Desondanks dat er in de correlatie figuur te zien was dat de de WCFS1 en NC8 stammen best wat uitelkaar lagen, lijkt er toch weinig verschil te zitten in de genen die van expressie niveau veranderen, tussen de twee stammen. 


## Cluster genes
Met hclust:
De `hclust()` functie heeft een afstandsmatrix nodig, om een hiërarchische structuur te maken. Dit kan worden aangemaakt met de `dist()` functie. Om ervoor te zorgen dat de condities en stammen gegproepeerd worden, en niet alle genen apart, moeten de rijen en kolommen van de counts matrix van het DGEList object worden omgewisseld, met `t()`.
```{r hclust}
distances = dist(t(y$counts))
plot(hclust(distances))
```

<br>
Een andere clusteringsmethode is `kmeans()`. kmeans maakt een clustering door te kijken naar hoe de datapunten samenliggen, en deelt de genen vervolgens in meerdere clusters (centers) in. Op hoeveel groepen er geclutstert moet worden, wordt opgegeven met de `centers` parameter. De wijze waarop dit gebeurt kan per run verschillen, waardoor het resultaat per run lichtelijk kan variëren. Om het resultaat te plotten, wordt er gebruik gemaakt van de `fviz_cluster()` functie van de package `factoextra`:
```{r kmeans, warning=FALSE, message=FALSE}
library(factoextra)
clustering = kmeans(y$counts, centers = 4)
fviz_cluster(clustering, y$counts, show.clust.cent = TRUE, geom = "point", ellipse = TRUE, main = "Clustering genen in 4 clusters")
```

## Results
Nu alle berekeningen gedaan zijn, kunnen er genen geselecteerd worden die aan bepaalde thresholds voldoen, om verder te onderzoeken en ze in een metabole pathway te plaatsen. De thresholds zijn een logFC value van hoger dan 1, of lager dan -1, en een FDR die kleiner is dan 1e-99. Omdat de FDR waarden niet weergegeven worden in de fit variabelen van de twee stammen, maar wel met de `topTags()` functie, werden er bij de "Calculate fold changes" stap twee nieuwe objecten aangemaakt, waarin alle genen met behulp van de `topTags()` functie werden opgeslagen, zodat de FDR waarde ook bij dat object in zat. Vervolgens kan er op logFC en FDR gefiltert worden, wat met behulp van de functie `filter` van de library `dpylr` was gedaan:
```{r results, warning=FALSE}
library(dplyr)
# Eerst voor WCFS1
wcfs1 = dplyr::filter(wcfs1$table, (wcfs1$table$logFC > 1 | wcfs1$table$logFC < -1) & wcfs1$table$FDR < 1e-99)
row.names.remove = c("lp_3545", "lp_0210")
wcfs1 = wcfs1[!(row.names(wcfs1) %in% row.names.remove), ]
wcfs1

nc8 = dplyr::filter(nc8$table, (nc8$table$logFC > 1 | nc8$table$logFC < -1) & nc8$table$FDR < 1e-99)
row.names.remove = c("lp_2684", "lp_2685")
nc8 = nc8[!(row.names(nc8) %in% row.names.remove), ]
nc8
```
De filtering is voor beide stammen apart gedaan. Na de filtering op logFC en FDR bleven er 17 genen in beide stammen over, waarvan er 15 in beide genen voorkwamen, en er 2 tussen de twee stammen verschilden. Omdat er ook vergeleken moet kunnen worden tussen de twee stammen, was er besloten om de genen die niet in beide stammen voorkwamen nog verder eruit te filteren, waardoor er 15 genen voor beide stammen overbleven. De uitgefilterde genen van de WCFS1 stam waren de lp_3545 en lp_0210 genen, en voor de NC8 stam de lp_2684 en de lp_2685 genen. 

Om de genen verder te onderzoeken, moeten de genen van annotatie worden voorzien. Deze annotatie van (bijna) elk gen was te vinden in het WCFS1_anno.tsv bestand, en is ingelezen met de `read.delim()` functie. Omdat er maar 15 genen over bleven na de filtering, hoeven ook alleen maar deze genen van annotatie te worden voorzien. Hiervoor was het annotatie dataframe gefilterd aan de hand  van de gennamen van de 15 overgebleven genen, en vervolgens worden de twee dataframes samengevoegt met de functie `merge()`, zodat genen van annotatie worden voorzien. Omdat er tijdens het inlezen van het annotatie bestand door een onbekende reden er teveel kolommen werden aangemaakt, werd de samengevoegde dataframe nog een keer gesubset, zodat deze kolommen uit de dataframe werden gehaald. 
```{r merge with annotation}
annotation_file = paste(here(), "WCFS1_anno.tsv", sep = "/")
anno_frame = read.delim(file = annotation_file, sep = "\t", header = TRUE, row.names = 1)

# voor WCFS1 
row.names.keep = row.names(wcfs1) # de 15 gennamen van de WCFS1 stam

filtered_anno = anno_frame[(row.names(anno_frame) %in% row.names.keep), ] # alleen de annotatie van de 15 genen wordt uit het annotatie dataframe gehaald, aan de hand van de gennaam

combined_wcfs1 = merge(wcfs1, filtered_anno, by=0, all = TRUE) # de twee dataframes worden gemerged. by=0 betekent aan de hand van row name, all = TRUE betekent dat wanneer een gen geen annotatie heeft, dat die alsnog in de combined frame wordt meegenomen (maar dan met NA values voor de kolommen)

combined_wcfs1 = combined_wcfs1[, 0:18] # de laatste paar kolommen worden eruit gehaald, want die horen er niet te staan
combined_wcfs1

# voor NC8
row.names.keep = row.names(nc8) # de 15 gennamen van de NC8 stam

filtered_anno = anno_frame[(row.names(anno_frame) %in% row.names.keep), ] # filter annotatie 

combined_nc8 = merge(nc8, filtered_anno, by=0, all = TRUE) # merge dataframes
combined_nc8 = combined_nc8[, 0:18] # verwijder laatste kolommen
combined_nc8
```

<br>

