---
title: "Data Analysation"
author: "Gabe van den Hoeven, Tom Ummenthun and Nick Somsen"
date: "datum-komt-hier"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
<br> <!-- voor een extra witregel -->

## Loading the dataset

Als eerst moet het bestand in R worden ingelezen. Dit is gedaan met behulp van de library here, die de current working directory met `here()` ophaald, en vervolgens wordt dit samengeplakt met een opgegeven bestandsnaam. Van de data in het bestand is vervolgens een data frame gemaakt met `read.table()`. De identifiers voor de rijen (`row.names`) zijn de gennamen, die in kolom 1 van het bestand staan.
``` {r create data frame, message = FALSE, warning = FALSE}
library(here)
file_name = paste(here(), "RNA-Seq-counts.txt", sep = "/")
data_frame = read.table(file = file_name, sep = "\t", header = TRUE, row.names = 1)
```

De data frame ziet er als volgt uit (alleen de eerste 10 regels):
```{r show data frame, echo=FALSE}
options(width = 100) # ik pas de breedte aan zodat alle kolommen op dezelfe line kunnen
head(data_frame, 10)
```

Om makkelijk met de count data te kunnen werken, wordt er van de data frame een DGEList object gemaakt. `DGEList()` is een functie van `edgeR`, die dus eerst nog geïmporteerd moet worden:
```{r load edgeR, message=FALSE}
library(edgeR)
```

Voor een DGEList moet de counts data (vanuit de dataset) en de groups worden opgegeven. De groups is een factor die de mogelijke condities van de samples aangeven (dus welke _L. plantarum_ stam het is en of het een glucose of ribose voedingsbodem is). Het aanmaken van die groups gaat als volgt (je hoeft niet aan te geven welke de eerste is en welke de duplo met 1 of 2; dat gebeurt later automatisch):
```{r factor for DGEList}
exp = c("WCFS1.glc","WCFS1.glc","WCFS1.rib","WCFS1.rib", "NC8.glc", "NC8.glc", "NC8.rib", "NC8.rib")
group = factor(exp)
```

Nu kan het DGEList object aangemaakt worden. Voor de `counts` parameter moeten de counts vanuit de dataframe geselecteerd worden. De `group` parameter is de eerder aangemaakte group factor.
```{r create DGEList}
y <- DGEList(counts=data_frame[,1:8], group=group)
testDGE = DGEList(counts=data_frame[,1:8], group=group)
```

Het printen van de DGEList leverd het volgende resultaat:
```{r show DGEList, echo=FALSE}
y
```

## Normalize the data
Zodat de data met elkaar vergeleken kan worden, moet de data genormaliseerd worden. Hierdoor wordt bijvoorbeeld het effect van biologischefactoren die buiten je macht om de data beïnvloeden, geminimaliseerd.

Er zijn verschillende manieren om data te normaliseren. Eén van deze manieren is de Trimmed Mean Method (TMM). De TMM methode is een normalisatie methode waarbij het gemiddelde pas wordt berekend, nadat een bepaalde hoeveelheid van de laagste en hoogste waarden van de dataset zijn verwijderd. De hoeveelheid waarden die van beide kanten worden weggegooid kunnen absolute aantallen zijn of percentages, vaak dezelfde hoeveelheid voor beide kanten. 

Nadat deze outliers van de dataset zijn verwijderd, wordt de trimmed mean bepaald aan de hand van een formule. De trimmed mean wordt gebruikt omdat het uitschieters niet mee neemt in de berekeningen, die anders de data op een negatieve manier zouden beïnvloeden. Bovendien wordt door het uitsluiten van de uitschieters een beter beeld van de werkelijkheid verkregen. 

De trimmed mean, en andere metingen en waarden, geven een basis voor de vergelijking van de data.

In R kan de trimmed mean normalisatie methode worden uitgevoer met `calcNormFactors()`, een functie van de `edgeR` library:
```{r normalize data}
y <- calcNormFactors(y, method="TMM")
testDGE = calcNormFactors(testDGE, method="TMM")
y
```
Alleen tijdens de berekening van de normalisatiefactoren worden de kleinste en hoogste waarde tijdelijk niet meegenomen, maar deze waarden blijven wel gewoon in het data object zitten. Wanneer er vervolgens verdere berekeningne worden gedaan met de dataset, zitten de kleinste en hoogste waarden hier dus gewoon weer bij. De vermeningvuldiging van counts met normalisatiefactor vindt automatisch plaats wanneer er met het data object gerekend wordt. 

Vervolgens wordt er een design matrix gemaakt, die data aan elkaar linkt. Een design matrix is "a matrix of values of explanatory variables of a set of objects. Each row represents an individual object, with the successive columns corresponding to the variables and their specific values for that object" [via https://en.wikipedia.org/wiki/Design_matrix]. In R kan er een design matrix worden gemaakt met de `model.matrix()` functie. Het object waarover de design matrix moet worden gemaakt wordt opgegeven als de eerste parameter. De data vanuit de data frame die gelinkt moet worden aan het object wordt met de `data` parameter opgegeven. De kolommen van de design matrix krijgen een naam met de `colnames()` functie.
```{r design matrix}
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- levels(y$samples$group)

testDesign = model.matrix(~0+group, data=y$samples)
colnames(testDesign) = levels(testDGE$samples$group)
```
De design matrix ziet er als volgt uit:
```{r view design matrix, echo=FALSE}
design
```

Na de normalisatie kan er nog gefilterd worden op low read counts. Soms hebben genen zulke lage read counts, dat ze niet interessant zijn voor dit onderzoek, en deze genen worden dan eruit gefilterd. `edgeR` heeft hier een functie voor: `filterByExpr`. Als parameters worden het DGEList object, de design matrix en een count threshold meegegeven. De `min.total.count` parameter geeft de threshold aan van het aantal read counts die één hele rij in de data frame moet hebben (dus over 8 kolommen). 4000 / 8 = 500 read counts moet elke kolom gemiddeld hebben, om significant te zijn. Met de niet gebruikte `min.count` parameter kan de threshold per kolom worden bepaald. Hiervoor is niet gekozen, omdat wanneer de ene stam bijvoorbeeld wel significant is, en de andere stam niet, dan blijven alleen de genen van één stam in de data zitten, waardoor je niet meer tussen de stammen kunt vergelijken.
```{r filter for low read counts}
keep = filterByExpr(y, design, min.total.count = 4000)
y = y[keep,]

testDGE = testDGE[keep,]
summary(keep) # 721 genen van de 2219 worden eruit gefilterd (~1/3)
```

## Calculate the dispersion
Om de spreiding tussen de data te bepalen, moet de dispersie worden berekent. Hiervoor zijn er verschillende functies beschikbaar in de `edgeR` library. Om zoveel mogelijk informatie te verkrijgen, worden er meerdere grafieken in dezelfde figuur geplot. Dit zijn de volgende grafieken:

1. De tagwise dispersie grafiek, waarbij elk datapunt één gen voor stelt.
2. De common dispersie grafiek, die een gemiddelde weer geeft van alle data, en daardoor constant is
3. De trend dispersie grafiek, die een trendlijn trekt door de tagwise datapunten.

Deze grafieken zijn met de volgende functies aangemaakt, en worden opgeslagen in het DGEList object:
```{r calculate dispersion}
testDGE = estimateGLMCommonDisp(testDGE,testDesign)  
testDGE = estimateGLMTrendedDisp(testDGE,testDesign, method="power") #op advies van Philip hadden we deze uitgezet.
testDGE = estimateGLMTagwiseDisp(testDGE,testDesign)
y = estimateDisp(y, design)
```

De dispersie kan dan als volgt worden geplot:
```{r dispersion plot}

temporaryplot = plotBCV(testDGE)
title("3 seperate commands")
correctplot = plotBCV(y)
title("1 single command")

```

In de figuur is te zien dat de variatie afneemt, naarmate de counts toenemen.

Ook kan nu de correlatie worden bepaald tussen de duplo's onderling, en over de verschillende condities en de _L. plantarum_ stammen. Dit kan in een grafiek worden geplot:
```{r correlation plot}
plotMDS(y)
```

In deze grafiek kan op de eerste dimensie (x-as) afgelezen worden hoever de glucose en ribose groepen uit elkaar liggen. Op de tweede dimensie (y-as) kan afgelezen worden hoever de duplo metingen uit elkaar liggen. Dit verschil tussen de duplo metingen moet klein zijn; was dit verschil groot geweest, dan betekent dat dat er veel verschillen zaten tussen de duplo metingen, wat ongewild is, en bovendien suggereerd dat de condities tijdens de twee metingen niet gelijk waren. Het verschil tussen de glucose en ribose condities mag logischerwijs wel groter zijn, net als de verschillen tussen de WCFS1 en NC8 stammen.

In de figuur is te zien dat bij beide _L. plantarum_ stammen de glucose en ribose metingen wat verder uit elkaar liggen (een afstand van ongeveer 2). In de tweede dimensie is te zien dat de twee stammen onderling ook ongeveer 2 uit elkaar liggen. Verder is er te zien dat er weinig verschil is tussen de duplo metingen, doordat de datapunten elkaar overlappen.

## Calculate fold changes
Om verschil tussen genexpressie te bepalen, worden de fold changes van de genexpressie levels berekend. Ook worden hiervoor p-values berekent, om betrouwbaarheid te controleren. Hiervoor moet er eerst een model worden gefit voor de read counts van elk gen. Dit wordt gedaan met `glmFit`, een functie van `edgeR`. Daarna kan het contrast tussen de verschillende groepen worden bepaald met de `makeContrasts` functie van de library `limma` (die tegelijk met `edgeR` wrodt ingeladen). Wanneer dat is gedaan, wordt er opniew een model gefit met de `glmLRT` functie, ook van `edgeR`. Omdat bij de `makeContrasts` functie maar twee groepen tegelijk met elkaar vergeleken kunnen worden, moeten deze stappen twee keer worden uitgevoerd: één keer voor het verschil in genexpressie van de verschillende voedingsbodems voor de WCFS1 stam en één keer hetzelfde voor de NC8 stam. 

Als eerst voor de WCFS1 stam:
```{r calculate fold changes WCFS1}
fit = glmFit(y, design)
mc = makeContrasts(exp.r=WCFS1.glc-WCFS1.rib, levels=design) 
fit = glmLRT(fit, contrast=mc)
```

De genen met het grootste verschil in fold changes (en dus expressie) tussen een glucose en ribose voedingsbodem van de WCFS1 stam kunnen dan worden weergegeven met `topTags`, dat defalut filtert op p-value:
```{r display top tags WCFS1}
res<-topTags(fit)
print(res)
```

En vervolgens voor de NC8 stam:
```{r calculate fold changes NC8}
fit = glmFit(y, design)
mc = makeContrasts(exp.r=NC8.glc-NC8.rib, levels=design) 
fit = glmLRT(fit, contrast=mc)
```

De genen met het grootste verschil in fold changes (en dus expressie) tussen een glucose en ribose voedingsbodem van de NC8 stam kunnen dan ook worden weergegeven:
```{r display top tags NC8}
res<-topTags(fit)
print(res)
```

Desondanks dat er in de correlatie figuur te zien was dat de de WCFS1 en NC8 stammen best wat uitelkaar lagen, lijkt er toch weinig verschil te zitten in de genen die van expressie niveau veranderen, tussen de twee stammen. De genen lp_2154 en lp_2151 zijn van positie omegewisseld tussen de twee stammen, en ook is het laatste gen in het rijtje voor beide stammen anders.

## Cluster genes
We moeten nog genen clusteren met hclust() of kmeans(). Bij hclust moeten eerst de afstanden worden berekend met dist, en daarna maakt hclust er een boomstructuur van. Hiervoor moest je wel de rijen en kolommen met t() eerst omwisselen, zodat je de sample groepen clustert, en niet elk gen apart.

Bij kmeans wordt de data verdeeld in groepen. Je moet zelf het aantal clusters opgeven. De data wordt dan gegroepeerd op punten die bij elkaar liggen. Er zit een randomisatie factor in, dus elke run kunnen het iets andere resultaten staan.

## Results
```{r results}
testvalue = fit$table[,4] # kolom 4 is de p-value kolom, dus dat moet volgensmij nog worden aangepast
#testvalue
```

<br>


