---
title: "Data Analysation"
author: "Gaben van den Hoeven, Tom Ummenthun and Nick Somsen"
date: "datum-komt-hier"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
<br> <!-- voor een extra witregel -->

## Loading the dataset

Als eerst moet het bestand in R worden ingelezen. Dit is gedaan met behulp van de library here, die de current working directory met `here()` ophaald, en vervolgens wordt dit samengeplakt met een opgegeven bestandsnaam. Van de data in het bestand is vervolgens een data frame gemaakt met `read.table()`. De identifiers voor de rijen (`row.names`) zijn de gennamen, die in kolom 1 van het bestand staan.
``` {r create data frame, message = FALSE, warning = FALSE}
library(here)
file_name = paste(here(), "RNA-Seq-counts.txt", sep = "/")
data_frame = read.table(file = file_name, sep = "\t", header = TRUE, row.names = 1)
```

De data frame ziet er als volgt uit (alleen de eerste 10 regels):
```{r show data frame, echo=FALSE}
options(width = 100) # ik pas de breedte aan zodat alle kolommen op dezelfe line kunnen
head(data_frame, 10)
```

Om makkelijk met de count data te kunnen werken, wordt er van de data frame een DGEList object gemaakt. `DGEList()` is een functie van `edgeR`, die dus eerst nog geïmporteerd moet worden:
```{r load edgeR, message=FALSE}
library(edgeR)
```

Voor een DGEList moet de counts data (vanuit de dataset) en de groups worden opgegeven. De groups is een factor die de mogelijke condities van de samples aangeven (dus welke _L. plantarum_ stam het is en of het een glucose of ribose voedingsbodem is). Het aanmaken van die groups gaat als volgt (je hoeft niet aan te geven welke de eerste is en welke de duplo met 1 of 2; dat gebeurt later automatisch):
```{r factor for DGEList}
exp = c("WCFS1.glc","WCFS1.glc","WCFS1.rib","WCFS1.rib", "NC8.glc", "NC8.glc", "NC8.rib", "NC8.rib")
group = factor(exp)
```

Nu kan het DGEList object aangemaakt worden. Voor de `counts` parameter moeten de counts vanuit de dataframe geselecteerd worden. De `group` parameter is de eerder aangemaakte group factor.
```{r create DGEList}
y <- DGEList(counts=data_frame[,1:8], group=group)
```

Het printen van de DGEList leverd het volgende resultaat:
```{r show DGEList, echo=FALSE}
y
```

## Normalize the data
Zodat de data met elkaar vergeleken kan worden, moet de data genormaliseerd worden. Hierdoor wordt bijvoorbeeld het effect van biologischefactoren die buiten je macht om de data beïnvloeden, geminimaliseerd.

Er zijn verschillende manieren om data te normaliseren. Eén van deze manieren is de Trimmed Mean Method (TMM). De TMM methode is een normalisatie methode waarbij het gemiddelde pas wordt berekend, nadat een bepaalde hoeveelheid van de laagste en hoogste waarden van de dataset zijn verwijderd. De hoeveelheid waarden die van beide kanten worden weggegooid kunnen absolute aantallen zijn of percentages, vaak dezelfde hoeveelheid voor beide kanten. 

Nadat deze outliers van de dataset zijn verwijderd, wordt de trimmed mean bepaald aan de hand van een formule. De trimmed mean wordt gebruikt omdat het uitschieters niet mee neemt in de berekeningen, die anders de data op een negatieve manier zouden beïnvloeden. Bovendien wordt door het uitsluiten van de uitschieters een beter beeld van de werkelijkheid verkregen. 

De trimmed mean, en andere metingen en waarden, geven een basis voor de vergelijking van de data.

In R kan de trimmed mean normalisatie methode worden uitgevoer met `calcNormFactors()`, een functie van de `edgeR` library:
```{r normalize data}
y <- calcNormFactors(y, method="TMM")
y
```
Wanneer de TMM methode als normalisatie methode wordt uitgevoerd, hoeft er niet meer gefilterd te worden op low reads.

Vervolgens wordt er een design matrix gemaakt, die data aan elkaar linkt. Een design matrix is "a matrix of values of explanatory variables of a set of objects. Each row represents an individual object, with the successive columns corresponding to the variables and their specific values for that object" [via https://en.wikipedia.org/wiki/Design_matrix]. In R kan er een design matrix worden gemaakt met de `model.matrix()` functie. Het object waarover de design matrix moet worden gemaakt wordt opgegeven als de eerste parameter. De data vanuit de data frame die gelinkt moet worden aan het object wordt met de `data` parameter opgegeven. De kolommen van de design matrix krijgen een naam met de `colnames()` functie.
```{r design matrix}
design <- model.matrix(~0+group, data=y$samples)
colnames(design) <- levels(y$samples$group)
```
De desing matrix ziet er als volgt uit:
```{r view design matrix, echo=FALSE}
design
```

## Calculate the dispersion
Om de spreiding tussen de data te bepalen, moet de dispersie worden berekent. Hiervoor zijn er verschillende functies beschikbaar in de `edgeR` library. Om zoveel mogelijk informatie te verkrijgen, worden er meerdere grafieken in dezelfde figuur geplot. Dit zijn de volgende grafieken:

1. De tagwise dispersie grafiek, waarbij elk datapunt één gen voor stelt.
2. De common dispersie grafiek, die een gemiddelde weer geeft van alle data, en daardoor constant is
3. De trend dispersie grafiek, die een trendlijn trekt door de tagwise datapunten.

Deze grafieken zijn met de volgende functies aangemaakt, en worden opgeslagen in het DGEList object:
```{r calculate dispersion}
y = estimateGLMCommonDisp(y,design)
y = estimateGLMTrendedDisp(y,design, method="power")
y = estimateGLMTagwiseDisp(y,design)
```

De dispersie kan dan als volgt worden geplot:
```{r dispersion plot}
plotBCV(y)
```

In de figuur is te zien dat de variatie afneemt, naarmate de counts toenemen.

Ook kan nu de correlatie worden bepaald tussen de duplo's onderling, en over de verschillende condities en de _L. plantarum_ stammen. Dit kan in een grafiek worden geplot:
```{r correlation plot}
plotMDS(y)
```

In deze grafiek kan op de eerste dimensie (x-as) afgelezen worden hoever de glucose en ribose groepen uit elkaar liggen. Op de tweede dimensie (y-as) kan afgelezen worden hoever de duplo metingen uit elkaar liggen. Dit verschil tussen de duplo metingen moet klein zijn; was dit verschil groot geweest, dan betekent dat dat er veel verschillen zaten tussen de duplo metingen, wat ongewild is, en bovendien suggereerd dat de condities tijdens de twee metingen niet gelijk waren. Het verschil tussen de glucose en ribose condities mag logischerwijs wel groter zijn, net als de verschillen tussen de WCFS1 en NC8 stammen.

In de figuur is te zien dat bij beide _L. plantarum_ stammen de glucose en ribose metingen wat verder uit elkaar liggen (een afstand van ongeveer 2). In de tweede dimensie is te zien dat de twee stammen onderling ook ongeveer 2 uit elkaar liggen. Verder is er te zien dat er weinig verschil is tussen de duplo metingen, doordat de datapunten elkaar overlappen.

## Calculate fold changes
Om verschil tussen genexpressie te bepalen, worden de fold changes van de genexpressie levels berekend. Ook worden hiervoor p-values berekent, om betrouwbaarheid te controleren. Hiervoor moet er eerst een model worden gefit voor de read counts van elk gen. Dit wordt gedaan met `glmFit`, een functie van `edgeR`. Daarna kan het contrast tussen de verschillende groepen worden bepaald met de `makeContrasts` functie van de library `limma` (die tegelijk met `edgeR` wrodt ingeladen). Wanneer dat is gedaan, wordt er opniew een model gefit met de `glmLRT` functie, ook van `edgeR`:
```{r calculate fold changes}
fit = glmFit(y, design)
mc = makeContrasts(exp.r=WCFS1.glc-WCFS1.rib, levels=design) # de exp.r parameter moet nog worden aangepast, want wij hebben ook NC8 erbij inzitten. Ik weet alleen niet hoe je die parameter moet aanpassen, want simpelweg NC8.glc-NC8.rib erachter zetten geeft vgm verkeerde resultaten
fit = glmLRT(fit, contrast=mc)
```

De genen met het grootste verschil in fold changes (en dus expressie) kunnen dan worden weergegeven met `topTags`:
```{r display top tags}
res<-topTags(fit)
print(res)
```

## Cluster genes
We moeten nog genen clusteren ofzo. Tilman zei dat dit met hclust() of kmeans() kan, maar ik heb geen idee hoe

## Results
```{r results}
testvalue = fit$table[,4]
testvalue
```

<br>


